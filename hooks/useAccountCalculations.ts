import { useMemo } from 'react';
import { Client, ClientWithDebt, Invoice, Payment, AccountAdjustment, Supplier, SupplierWithDebt, Purchase, SupplierPayment } from '../types';
import { type ClientHistoryItem } from '../components/clients/ClientHistoryTable.tsx';


export function useClientsWithDebtCalculator(
    rawClients: Client[],
    rawInvoices: Invoice[],
    rawPayments: Payment[],
    rawAdjustments: AccountAdjustment[]
): ClientWithDebt[] {
    return useMemo(() => {
        const paymentsByClient = new Map<string, number>();
        for (const payment of rawPayments) {
            paymentsByClient.set(payment.clientId, (paymentsByClient.get(payment.clientId) || 0) + payment.amountARS);
        }

        const debtByClient = new Map<string, number>();
        for (const invoice of rawInvoices) {
            // DEBT IS ONLY GENERATED BY 'CTA_CTE' INVOICES
            if (invoice.paymentMethod === 'CTA_CTE' && (invoice.status === 'PENDIENTE_PAGO' || invoice.status === 'PAGADA') && invoice.clientId) {
                debtByClient.set(invoice.clientId, (debtByClient.get(invoice.clientId) || 0) + invoice.totals.totalARS);
            }
        }
        
        const adjustmentsByClient = new Map<string, number>();
        for (const adj of rawAdjustments) {
            const amount = adj.type === 'DEBIT' ? adj.amountARS : -adj.amountARS;
            adjustmentsByClient.set(adj.clientId, (adjustmentsByClient.get(adj.clientId) || 0) + amount);
        }

        return rawClients.map(client => {
            const totalInvoiced = debtByClient.get(client.id) || 0;
            const totalPaid = paymentsByClient.get(client.id) || 0;
            const totalAdjustments = adjustmentsByClient.get(client.id) || 0;
            return { ...client, debt: totalInvoiced - totalPaid + totalAdjustments };
        });

    }, [rawClients, rawInvoices, rawPayments, rawAdjustments]);
}

export function useClientDetailCalculations(
    invoices: Invoice[],
    payments: Payment[],
    adjustments: AccountAdjustment[]
): { debt: number; history: ClientHistoryItem[] } {
    return useMemo(() => {
        const totalInvoiced = invoices
            // DEBT IS ONLY GENERATED BY 'CTA_CTE' INVOICES
            .filter(inv => inv.paymentMethod === 'CTA_CTE' && (inv.status === 'PENDIENTE_PAGO' || inv.status === 'PAGADA'))
            .reduce((sum, inv) => sum + inv.totals.totalARS, 0);
        
        const totalPaid = payments.reduce((sum, p) => sum + p.amountARS, 0);

        const totalAdjustments = adjustments.reduce((sum, adj) => {
            return sum + (adj.type === 'DEBIT' ? adj.amountARS : -adj.amountARS);
        }, 0);
        
        const debt = totalInvoiced - totalPaid + totalAdjustments;

        const invoiceHistory: ClientHistoryItem[] = invoices
            .filter(inv => inv.status === 'PENDIENTE_PAGO' || inv.status === 'PAGADA')
            .map(inv => ({
                type: 'FACTURA',
                date: inv.createdAt,
                amountARS: inv.totals.totalARS,
                data: { id: inv.id, description: `Factura ${inv.pos}-${inv.number} (${inv.paymentMethod === 'CTA_CTE' ? 'Cta. Cte.' : inv.paymentMethod})` }
            }));

        const paymentHistory: ClientHistoryItem[] = payments
            .map(p => {
                let description = `Pago recibido (${p.paymentMethod})`;
                if (p.paymentMethod === 'CHEQUE' && p.chequeDetails) {
                    const paymentDateStr = new Date(p.chequeDetails.paymentDate).toLocaleDateString('es-AR');
                    description = `Pago recibido (CHEQUE NÂ° ${p.chequeDetails.number} p/ ${paymentDateStr})`;
                }
                return {
                    type: 'PAGO' as 'PAGO',
                    date: p.date,
                    amountARS: -p.amountARS,
                    note: p.notes,
                    data: { id: p.id, description }
                };
            });

        const adjustmentHistory: ClientHistoryItem[] = adjustments
            .map(adj => ({
                type: 'AJUSTE',
                date: adj.date,
                amountARS: adj.type === 'DEBIT' ? adj.amountARS : -adj.amountARS,
                data: { id: adj.id, description: `${adj.description} (${adj.type})` }
            }));

        const history: ClientHistoryItem[] = [...invoiceHistory, ...paymentHistory, ...adjustmentHistory]
            .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());

        // Recalculate amounts to be positive for display, but keep original for calculation logic
        const displayHistory = history.map(h => ({...h, amountARS: Math.abs(h.amountARS || 0)}));

        return { debt, history: displayHistory };
    }, [invoices, payments, adjustments]);
}

export function useSuppliersWithDebtCalculator(
    rawSuppliers: Supplier[],
    rawPurchases: Purchase[],
    rawPayments: SupplierPayment[]
): SupplierWithDebt[] {
    return useMemo(() => {
        const debtBySupplier = new Map<string, number>();
        rawPurchases.forEach(p => {
            if (p.status === 'PENDIENTE') { // Only pending invoices contribute to debt
                 debtBySupplier.set(p.supplierId, (debtBySupplier.get(p.supplierId) || 0) + p.totalAmountARS);
            }
        });
        
        // This is a simplified model. A more accurate model would sum all purchases and subtract all payments.
        // Let's use the more accurate model.
        const purchaseTotals = new Map<string, number>();
         rawPurchases.forEach(p => {
             if (p.status !== 'ANULADA') {
                purchaseTotals.set(p.supplierId, (purchaseTotals.get(p.supplierId) || 0) + p.totalAmountARS);
             }
        });

        const paymentTotals = new Map<string, number>();
        rawPayments.forEach(p => {
            paymentTotals.set(p.supplierId, (paymentTotals.get(p.supplierId) || 0) + p.amountARS);
        });

        return rawSuppliers.map(s => {
            const totalPurchased = purchaseTotals.get(s.id) || 0;
            const totalPaid = paymentTotals.get(s.id) || 0;
            return {
                ...s,
                debt: totalPurchased - totalPaid,
            }
        });

    }, [rawSuppliers, rawPurchases, rawPayments]);
}


export function useSupplierDetailCalculations(
    purchases: Purchase[],
    payments: SupplierPayment[]
): { debt: number } {
    return useMemo(() => {
        const totalPurchased = purchases
            .filter(p => p.status !== 'ANULADA')
            .reduce((sum, p) => sum + p.totalAmountARS, 0);

        const totalPaid = payments.reduce((sum, p) => sum + p.amountARS, 0);
        
        const debt = totalPurchased - totalPaid;

        return { debt };
    }, [purchases, payments]);
}